#!/usr/bin/env ruby

require 'discordrb'
require 'base64'

_token = File.read(File.dirname(__FILE__) + "/.token").gsub(/\n/,"")

bot = Discordrb::Commands::CommandBot.new(token: _token, prefix: '!') #, 
    # advanced_functionality: false)
rlimit = Discordrb::Commands::SimpleRateLimiter.new

CreatorB = 'XIIISins'

# Message responders
bot.message(with_text: 'Ping!') do |_event|
    _event.respond 'Pong!'
end

## Put back the table
rlimit.bucket :table, delay: 5
bot.message(containing: ['(╯°□°）╯︵ ┻━┻', '(ﾉಥ益ಥ）ﾉ﻿ ┻━┻', '(ノಠ益ಠ)ノ彡┻━┻']
    ) do |_event|
  next if rlimit.rate_limited?(:table, event.channel)
  _event.respond '┬─┬ノ( º _ ºノ)'
end


# Commands
# bot.command(:command_name, description: '<description',
#     usage: 'Useful info on how to use', min_args: 1) do |_event, var|
#     # stuff here
# end

bot.bucket :echo, limit: 10, time_span: 60, delay: 6

bot.command(:echo, bucket: :echo, 
    rate_limit_message: 'Command called too soon, try again in %time% seconds', 
    description: 'repeat whatever u say', 
    usage: 'echo <text>', min_args: 1) do |_event, *echo|
    _event.respond(echo.join(' '))
end

bot.command(:repass, description: 'Create password', 
    usage: 'repass <random text>', min_args: 1) do |_event, *pass|
    pw = pass.join("").gsub(/\n/, "") + "\xFE"
    _event.respond(Base64.encode64(pw))
end

bot.command(:diablo, description: 'Diablo builds',
    usage: 'diablo <class>', min_args: 1) do |_event, *req|
    # Demon Hunter
    _D3_DH_beginner_url = "http://www.diablofans.com/builds/96034-natalya-rain-of-vengeance-build"
    _D3_DH_intermediate_url = "http://www.diablofans.com/builds/96089-unhallowed-multishot-t13-and-gr85-fast"
    # Monk
    _D3_MK_beginner_url = "http://www.diablofans.com/builds/96080-uliana-simple-gr70-video-tutorial"
    _D3_MK_advanced_url = "http://www.diablofans.com/builds/96035-s12-swk-wol-solo-100-or-group"
    _D3_MK_supp_url = "http://www.diablofans.com/builds/96224-support-monk"
    
    _D3_Class = [{ 
      optn: ["Demon Hunter", "DH", ],
      func: Proc.new { 
          "Beginner = " + _D3_DH_beginner_url + 
          "\nIntermediate = " + _D3_DH_intermediate_url 
      }
    },{ 
      optn: ["Monk"],
      func: Proc.new { 
          "Beginner = " + _D3_MK_beginner_url +
          "\nSupport  = " + _D3_MK_supp_url +
          "\nAdvanced = " + _D3_MK_advanced_url 
      } 
    },{ 
      optn: ["Barbarian", "barb"],
      func: Proc.new { 
        "I don't know guides for this class, If you know a good one let " + 
        CreatorB + "know." 
      } 
    },{
      optn: ["Wizard", "wiz"],
      func: Proc.new {
        "I don't know guides for this class, If you know a good one let " + 
        CreatorB + "know."
      }
    },{ 
      optn: ["Witch Doctor", "WD"],
      func: Proc.new { 
        "I don't know guides for this class, If you know a good one let " + 
        CreatorB + "know." 
      } 
    },{ 
      optn: ["Crusader", "crus"],
      func: Proc.new { 
        "I don't know guides for this class, If you know a good one let " + 
        CreatorB + "know." 
      }
    },{
      optn: ["Necromancer", "necro"],
      func: Proc.new {
       "I don't know guides for this class, If you know a good one let " + 
       CreatorB + "know."  
      }
    }]

    gclass = req.kind_of?(Array) ? req.join(" ") : req

    response = _D3_Class.map { |c| c[:func].call if gclass.match( Regexp.new(/\s?(#{c[:optn].join("|")})\s?/i) ) }.join(" ")

    # if response.to_s.empty?
    # if response.match(/^[[:space:]]*$/)
    if response =~ /^\s*$/ || response.to_s.empty?
      _event.respond(
        "Could not read class, please use one of the following:\n" + 
        _D3_Class.map { |c| c[:optn].join(", ")}.join(", ")
      )
    else 
      _event.respond(response)
    end
end

bot.run
